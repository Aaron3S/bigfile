// Code generated by protoc-gen-go. DO NOT EDIT.
// source: image_convert.proto

package rpc

import (
	context "context"
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// FileReadRequest represent the token delete request
type ImageConvertRequest struct {
	Token                string                `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	FileUid              string                `protobuf:"bytes,2,opt,name=file_uid,json=fileUid,proto3" json:"file_uid,omitempty"`
	Type                 string                `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Width                uint32                `protobuf:"varint,5,opt,name=width,proto3" json:"width,omitempty"`
	Height               uint32                `protobuf:"varint,6,opt,name=height,proto3" json:"height,omitempty"`
	Left                 int32                 `protobuf:"varint,7,opt,name=left,proto3" json:"left,omitempty"`
	Top                  int32                 `protobuf:"varint,8,opt,name=top,proto3" json:"top,omitempty"`
	Secret               *wrappers.StringValue `protobuf:"bytes,4,opt,name=secret,proto3" json:"secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ImageConvertRequest) Reset()         { *m = ImageConvertRequest{} }
func (m *ImageConvertRequest) String() string { return proto.CompactTextString(m) }
func (*ImageConvertRequest) ProtoMessage()    {}
func (*ImageConvertRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_66265b5e936213c9, []int{0}
}

func (m *ImageConvertRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageConvertRequest.Unmarshal(m, b)
}
func (m *ImageConvertRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageConvertRequest.Marshal(b, m, deterministic)
}
func (m *ImageConvertRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageConvertRequest.Merge(m, src)
}
func (m *ImageConvertRequest) XXX_Size() int {
	return xxx_messageInfo_ImageConvertRequest.Size(m)
}
func (m *ImageConvertRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageConvertRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ImageConvertRequest proto.InternalMessageInfo

func (m *ImageConvertRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *ImageConvertRequest) GetFileUid() string {
	if m != nil {
		return m.FileUid
	}
	return ""
}

func (m *ImageConvertRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ImageConvertRequest) GetWidth() uint32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *ImageConvertRequest) GetHeight() uint32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ImageConvertRequest) GetLeft() int32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *ImageConvertRequest) GetTop() int32 {
	if m != nil {
		return m.Top
	}
	return 0
}

func (m *ImageConvertRequest) GetSecret() *wrappers.StringValue {
	if m != nil {
		return m.Secret
	}
	return nil
}

// FileReadResponse represent the token delete response
type ImageConvertResponse struct {
	Content              []byte   `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ImageConvertResponse) Reset()         { *m = ImageConvertResponse{} }
func (m *ImageConvertResponse) String() string { return proto.CompactTextString(m) }
func (*ImageConvertResponse) ProtoMessage()    {}
func (*ImageConvertResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_66265b5e936213c9, []int{1}
}

func (m *ImageConvertResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ImageConvertResponse.Unmarshal(m, b)
}
func (m *ImageConvertResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ImageConvertResponse.Marshal(b, m, deterministic)
}
func (m *ImageConvertResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageConvertResponse.Merge(m, src)
}
func (m *ImageConvertResponse) XXX_Size() int {
	return xxx_messageInfo_ImageConvertResponse.Size(m)
}
func (m *ImageConvertResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageConvertResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ImageConvertResponse proto.InternalMessageInfo

func (m *ImageConvertResponse) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func init() {
	proto.RegisterType((*ImageConvertRequest)(nil), "bigfile.file_read.ImageConvertRequest")
	proto.RegisterType((*ImageConvertResponse)(nil), "bigfile.file_read.ImageConvertResponse")
}

func init() { proto.RegisterFile("image_convert.proto", fileDescriptor_66265b5e936213c9) }

var fileDescriptor_66265b5e936213c9 = []byte{
	// 374 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x50, 0xcb, 0xae, 0xd3, 0x30,
	0x10, 0xc5, 0x7d, 0xa4, 0xc5, 0xb4, 0x12, 0xb8, 0x15, 0x32, 0x15, 0x2a, 0x51, 0x17, 0x90, 0x95,
	0x5b, 0x15, 0xbe, 0x20, 0x48, 0x48, 0x88, 0x4d, 0x64, 0x5e, 0x12, 0x9b, 0x2a, 0x8f, 0x69, 0x62,
	0x91, 0xda, 0xc6, 0x71, 0xa8, 0xfa, 0x3b, 0x2c, 0xf9, 0x2e, 0x3e, 0x82, 0x25, 0x8a, 0x93, 0x54,
	0x5c, 0xdd, 0x2b, 0xdd, 0x8d, 0x3d, 0xe7, 0xf8, 0xcc, 0x19, 0x9f, 0xc1, 0x0b, 0x71, 0x8a, 0x73,
	0x38, 0xa4, 0x4a, 0xfe, 0x04, 0x63, 0x99, 0x36, 0xca, 0x2a, 0xf2, 0x24, 0x11, 0xf9, 0x51, 0x94,
	0xc0, 0x9a, 0xe3, 0x60, 0x20, 0xce, 0x56, 0xeb, 0x5c, 0xa9, 0xbc, 0x84, 0xad, 0x13, 0x24, 0xf5,
	0x71, 0x7b, 0x36, 0xb1, 0xd6, 0x60, 0xaa, 0xb6, 0x65, 0xf3, 0x07, 0xe1, 0xc5, 0xfb, 0xc6, 0xea,
	0x6d, 0xeb, 0xc4, 0xe1, 0x47, 0x0d, 0x95, 0x25, 0x4b, 0x3c, 0xb6, 0xea, 0x3b, 0x48, 0x8a, 0x7c,
	0x14, 0x3c, 0xe4, 0x2d, 0x20, 0xcf, 0xf0, 0xd4, 0x59, 0xd7, 0x22, 0xa3, 0x03, 0xf7, 0x30, 0x69,
	0xf0, 0x67, 0x91, 0x11, 0x82, 0x47, 0xf6, 0xa2, 0x81, 0x0e, 0x1d, 0xed, 0xea, 0xc6, 0xe4, 0x2c,
	0x32, 0x5b, 0xd0, 0xb1, 0x8f, 0x82, 0x39, 0x6f, 0x01, 0x79, 0x8a, 0xbd, 0x02, 0x44, 0x5e, 0x58,
	0xea, 0x39, 0xba, 0x43, 0x8d, 0x43, 0x09, 0x47, 0x4b, 0x27, 0x3e, 0x0a, 0xc6, 0xdc, 0xd5, 0xe4,
	0x31, 0x1e, 0x5a, 0xa5, 0xe9, 0xd4, 0x51, 0x4d, 0x49, 0xde, 0x60, 0xaf, 0x82, 0xd4, 0x80, 0xa5,
	0x23, 0x1f, 0x05, 0x8f, 0xf6, 0xcf, 0x59, 0x9b, 0x90, 0xf5, 0x09, 0xd9, 0x47, 0x6b, 0x84, 0xcc,
	0xbf, 0xc4, 0x65, 0x0d, 0xbc, 0xd3, 0x6e, 0x76, 0x78, 0x79, 0x33, 0x65, 0xa5, 0x95, 0xac, 0x80,
	0x50, 0x3c, 0x49, 0x95, 0xb4, 0x20, 0xad, 0x0b, 0x3a, 0xe3, 0x3d, 0xdc, 0x2b, 0x3c, 0xfb, 0xbf,
	0x83, 0x1c, 0xda, 0xe8, 0x1c, 0xe2, 0x8c, 0xbc, 0x64, 0xb7, 0x16, 0xcd, 0xee, 0x58, 0xe2, 0xea,
	0xd5, 0xbd, 0xba, 0xf6, 0x1b, 0x9b, 0x07, 0x3b, 0x14, 0x1a, 0xbc, 0x4c, 0xd5, 0xe9, 0xda, 0xd1,
	0xc7, 0x09, 0xe7, 0xef, 0xba, 0xb1, 0x51, 0xc3, 0x44, 0xe8, 0xdb, 0x3a, 0x17, 0xb6, 0xa8, 0x13,
	0x96, 0xaa, 0xd3, 0xb6, 0x53, 0x5f, 0x6f, 0xa3, 0xd3, 0xbf, 0x08, 0xfd, 0x1a, 0x0c, 0xc3, 0x88,
	0xff, 0x1e, 0xbc, 0x08, 0x3b, 0xb3, 0xa8, 0xdf, 0xcd, 0x57, 0x28, 0xcb, 0x0f, 0x52, 0x9d, 0xe5,
	0xa7, 0x8b, 0x86, 0x2a, 0xf1, 0xdc, 0x94, 0xd7, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x4d, 0xea,
	0x67, 0x70, 0x4e, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ImageConvertClient is the client API for ImageConvert service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ImageConvertClient interface {
	FileRead(ctx context.Context, in *ImageConvertRequest, opts ...grpc.CallOption) (ImageConvert_FileReadClient, error)
}

type imageConvertClient struct {
	cc *grpc.ClientConn
}

func NewImageConvertClient(cc *grpc.ClientConn) ImageConvertClient {
	return &imageConvertClient{cc}
}

func (c *imageConvertClient) FileRead(ctx context.Context, in *ImageConvertRequest, opts ...grpc.CallOption) (ImageConvert_FileReadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_ImageConvert_serviceDesc.Streams[0], "/bigfile.file_read.ImageConvert/fileRead", opts...)
	if err != nil {
		return nil, err
	}
	x := &imageConvertFileReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ImageConvert_FileReadClient interface {
	Recv() (*ImageConvertResponse, error)
	grpc.ClientStream
}

type imageConvertFileReadClient struct {
	grpc.ClientStream
}

func (x *imageConvertFileReadClient) Recv() (*ImageConvertResponse, error) {
	m := new(ImageConvertResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// ImageConvertServer is the server API for ImageConvert service.
type ImageConvertServer interface {
	FileRead(*ImageConvertRequest, ImageConvert_FileReadServer) error
}

// UnimplementedImageConvertServer can be embedded to have forward compatible implementations.
type UnimplementedImageConvertServer struct {
}

func (*UnimplementedImageConvertServer) FileRead(req *ImageConvertRequest, srv ImageConvert_FileReadServer) error {
	return status.Errorf(codes.Unimplemented, "method FileRead not implemented")
}

func RegisterImageConvertServer(s *grpc.Server, srv ImageConvertServer) {
	s.RegisterService(&_ImageConvert_serviceDesc, srv)
}

func _ImageConvert_FileRead_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ImageConvertRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ImageConvertServer).FileRead(m, &imageConvertFileReadServer{stream})
}

type ImageConvert_FileReadServer interface {
	Send(*ImageConvertResponse) error
	grpc.ServerStream
}

type imageConvertFileReadServer struct {
	grpc.ServerStream
}

func (x *imageConvertFileReadServer) Send(m *ImageConvertResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _ImageConvert_serviceDesc = grpc.ServiceDesc{
	ServiceName: "bigfile.file_read.ImageConvert",
	HandlerType: (*ImageConvertServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "fileRead",
			Handler:       _ImageConvert_FileRead_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "image_convert.proto",
}
